/*
*Name: Lawrence Milne
*STD NUM: 1044930
*email: lmilne01
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include "SVGParser.h"
#include "xmlParser.h"
#include "util.h"
#include "SVGToXML.h"
#include "svgEditor.h"
/******************************************************** A2 stuff ********************************/
/** Function to validating an existing a SVGimage object against a SVG schema file
 *@pre
    SVGimage object exists and is not NULL
    schema file name is not NULL/empty, and represents a valid schema file
 *@post SVGimage has not been modified in any way
 *@return the boolean aud indicating whether the SVGimage is valid
 *@param obj - a pointer to a GPXSVGimagedoc struct
 *@param obj - the name iof a schema file
 **/
bool validateSVGimage(SVGimage* image, char* schemaFile){
    bool isValid = false;

    //check if its valid with the xml parser
    xmlDoc* doc = SVGimageToTree(image);
    isValid = IsValidSVG(doc,schemaFile);
    if(doc)
      xmlFreeDoc(doc);

     if(isValid){ //if its valid from the xml parser check the rest
         isValid = checkSVGimage(image);
     }
     xmlCleanupParser();
    return isValid;
}

/** Function to create an SVG object based on the contents of an SVG file.
 * This function must validate the XML tree generated by libxml against a SVG schema file
 * before attempting to traverse the tree and create an SVGimage struct
 *@pre File name cannot be an empty string or NULL.
       File represented by this name must exist and must be readable.
       Schema file name is not NULL/empty, and represents a valid schema file
 *@post Either:
        A valid SVGimage has been created and its address was returned
		or
		An error occurred, or SVG file was invalid, and NULL was returned
 *@return the pinter to the new struct or NULL
 *@param fileName - a string containing the name of the SVG file
**/
SVGimage* createValidSVGimage(char* fileName, char* schemaFile){
    xmlDoc* doc = NULL;
    xmlNode* rootNode = NULL;
    SVGimage* img = NULL;

    //init the library
    if(fileName && schemaFile){

        LIBXML_TEST_VERSION

        /*parse the file and get the DOM */
        doc = xmlReadFile(fileName, NULL, 0);
        rootNode = xmlDocGetRootElement(doc);
        if(doc && IsValidSVG(doc,schemaFile)){
            img = malloc(sizeof(SVGimage));
            initImage(img);
            parseXML(img,rootNode);
            if(!checkSVGimage(img)){ //image was invalid
                deleteSVGimage(img);
                img = NULL;
            }
        }

        /*free the document */
        if(doc) xmlFreeDoc(doc);

        /*
         *Free the global variables that may
         *have been allocated by the parser.
         */
        xmlCleanupParser();


    }
    return img;
}

/** Function to writing a SVGimage into a file in SVG format.
 *@pre
    SVGimage object exists, is valid, and and is not NULL.
    fileName is not NULL, has the correct extension
 *@post SVGimage has not been modified in any way, and a file representing the
    SVGimage contents in SVG format has been created
 *@return a boolean value indicating success or failure of the write
 *@param
    doc - a pointer to a SVGimage struct
 	fileName - the name of the output file
 **/
bool writeSVGimage(SVGimage* image, char* fileName){
    if(!image || !fileName){
        return false;
    }

    xmlDoc* doc = SVGimageToTree(image);

    if(doc){
        xmlSaveFormatFileEnc( fileName, doc,"UTF-8",1);
        xmlFreeDoc(doc);
    }
    xmlCleanupParser();
    return true;
}


/** Function to setting an attribute in an SVGimage or component
 *@pre
    SVGimage object exists, is valid, and and is not NULL.
    newAttribute is not NULL
 *@post The appropriate attribute was set corectly
 *@return N/A
 *@param
    image - a pointer to an SVGimage struct
    elemType - enum value indicating elemtn to modify
    elemIndex - index of thje lement to modify
    newAttribute - struct containing name and value of the updated attribute
 **/
void setAttribute(SVGimage* image, elementType elemType, int elemIndex, Attribute* newAttribute){
    //IDEA: simple case statement for elementType or make an array of function pointers and pass based on index
    //in elem type
    /**This array holds the functions pointers used to set attributes in the lists.
     * it is based on the same index as elemType
     *typedef enum COMP{ SVG_IMAGE, CIRC, RECT, PATH, GROUP } elementType;
     */
    void (*setAttributeFunctions[5])(SVGimage*, int, Attribute*) = {addAttrSVGimage, addAttrCircle,addAttrRect,addAttrPath,addAttrGroup};

    if(!image || !newAttribute || !checkAttribute(newAttribute)){
        return;
    }
    //checks bounds and adds the attribute if it exists
    if(elemType >= SVG_IMAGE && elemType <= GROUP){
        setAttributeFunctions[elemType](image,elemIndex,newAttribute);
    }


}


/** Function to adding an element - Circle, Rectngle, or Path - to an SVGimage
 *@pre
    SVGimage object exists, is valid, and and is not NULL.
    newElement is not NULL
 *@post The appropriate element was added correctly
 *@return N/A
 *@param
    image - a pointer to an SVGimage struct
    elemType - enum value indicating elemtn to modify
    newElement - pointer to the element sgtruct (Circle, Rectngle, or Path)
 **/
void addComponent(SVGimage* image, elementType type, void* newElement){

    void (*addCompFunctions[5])(SVGimage*, void*) = {NULL, addCircle,addRect,addPath,NULL};

    if(!newElement || !image) return;
    //todo check index bounds >=1 <=4
    if(type > SVG_IMAGE && type < GROUP){
        addCompFunctions[type](image,newElement);
    }

}

/** Function to converting an Attribute into a JSON string
*@pre Attribute is not NULL
*@post Attribute has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to an Attribute struct
**/
char* attrToJSON(const Attribute *a){
  char* json = NULL;
  Attribute* attr = (Attribute*)a;
  if(attr && attr->name && attr->value){
    json = malloc(sizeof(char)*(strlen(a->name) + strlen(attr->value) + strlen("{\"name\":\"\",\"value\":\"\"}") + 1));

    sprintf(json,"{\"name\":\"%s\",\"value\":\"%s\"}",attr->name,attr->value);

  } else{
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"{}");
  }

  return json;
}

/** Function to converting a Circle into a JSON string
*@pre Circle is not NULL
*@post Circle has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a Circle struct
**/
char* circleToJSON(const Circle *c){
  char* json = NULL;
  Circle* circle = (Circle*)c;
  if(circle){
    char xVal[1000];
    char yVal[1000];
    char rVal[1000];
    char attVal[1000];

    //get x's value
    sprintf(xVal,"%.2f", circle->cx);

    //get y's value
    sprintf(yVal,"%.2f", circle->cy);

    //gets radius
    sprintf(rVal,"%.2f", circle->r);

    //get num  of attributes
    if(circle->otherAttributes){
      sprintf(attVal,"%d",getLength(circle->otherAttributes));
    } else {
      strcpy(attVal,"0");
    }

    json = malloc(sizeof(char)*(strlen(circle->units) + strlen("{\"cx\":,\"cy\":,\"r\":,\"numAttr\":,\"units\":\"\"}") +
                                strlen(xVal) +strlen(yVal) + strlen(rVal) + strlen(attVal) + 1));

    sprintf(json,"{\"cx\":%s,\"cy\":%s,\"r\":%s,\"numAttr\":%s,\"units\":\"%s\"}",xVal, yVal, rVal, attVal,circle->units);

  } else{
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"{}");
  }

  return json;
}

/** Function to converting a Rectangle into a JSON string
*@pre Rectangle is not NULL
*@post Rectangle has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a Rectangle struct
**/
char* rectToJSON(const Rectangle *r){
  char* json = NULL;
  Rectangle* rect = (Rectangle*)r;
  if(rect){
    char xVal[1000];
    char yVal[1000];
    char widthVal[1000];
    char heightVal[1000];
    char attVal[1000];

    //get x's value
    sprintf(xVal,"%.2f", rect->x);

    //get y's value
    sprintf(yVal,"%.2f", rect->y);

    //gets width
    sprintf(widthVal,"%.2f", rect->width);

    //get height
    sprintf(heightVal,"%.2f", rect->height);

    //get num  of attributes
    if(r->otherAttributes){
      sprintf(attVal,"%d",getLength(rect->otherAttributes));
    } else {
      strcpy(attVal,"0");
    }

    json = malloc(sizeof(char)*(strlen(rect->units) + strlen("{\"x\":,\"y\":,\"w\":,\"h\":,\"numAttr\":,\"units\":\"\"}") +
                                strlen(xVal) +strlen(yVal) + strlen(widthVal) + strlen(heightVal) + strlen(attVal) + 1));

    sprintf(json,"{\"x\":%s,\"y\":%s,\"w\":%s,\"h\":%s,\"numAttr\":%s,\"units\":\"%s\"}",xVal, yVal, widthVal, heightVal, attVal,rect->units);

  } else{
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"{}");
  }

  return json;
}

/** Function to converting a Path into a JSON string
*@pre Path is not NULL
*@post Path has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a Path struct
**/
char* pathToJSON(const Path *p){
  char* json = NULL;
  Path* path = (Path*)p;
  //checks if its valid to be turned to a string
  if(path && path->data){
    //buffer for ints no int is big enough to overflow it
    char attVal[1000];
    *attVal = '\0';
    if(path->otherAttributes){
      sprintf(attVal,"%d",getLength(path->otherAttributes));
    } else {
      strcpy(attVal,"0");
    }
    if(strlen(path->data) <= 64){
        json = malloc(sizeof(char)*(strlen(path->data) + strlen(attVal) + strlen("{\"d\":\"\",\"numAttr\":}") + 1));
    } else{//allocate 64 bytes for path must get truncated
        json = malloc(sizeof(char)*(64 + strlen(attVal) + strlen("{\"d\":\"\",\"numAttr\":}") + 1));

    }
    //copies first have of json string
    strcpy(json,"{\"d\":\"");
    strncat(json,path->data,64); //truncates the string to 64 if it is longer
    strcat(json,"\",\"numAttr\":");
    strcat(json,attVal);
    strcat(json,"}");
    //sprintf(json,"{\"d\":\"%s\",\"numAttr\":%s}",path->data,attVal);

  } else{ //not valid
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"{}");
  }

  return json;
}

/** Function to converting a Group into a JSON string
*@pre Group is not NULL
*@post Group has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a Group struct
**/
char* groupToJSON(const Group *g){
  char* json = NULL;
  Group* group = (Group*)g;
  //checks if its valid to be turned to a string
  if(group){

    //holds how many children there area
    int childCount = 0;
    childCount += getLength(group->rectangles);
    childCount += getLength(group->circles);
    childCount += getLength(group->paths);
    childCount += getLength(group->groups);

    //buffer for ints no int is big enough to overflow it
    char attVal[1000];
    char childVal[1000];

    //get x's value
    sprintf(childVal,"%d", childCount);

    if(g->otherAttributes){
      sprintf(attVal,"%d",getLength(group->otherAttributes));
    } else {
      strcpy(attVal,"0");
    }
    json = malloc(sizeof(char)*(+ strlen(attVal) + strlen(childVal) + strlen("{\"children\":,\"numAttr\":}") + 1));

    sprintf(json,"{\"children\":%s,\"numAttr\":%s}",childVal,attVal);

  } else{ //not valid
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"{}");
  }

  return json;
}

/** Function to converting a list of Attribute structs into a JSON string
*@pre Attribute list is not NULL
*@post Attribute list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* attrListToJSON(const List *list){
  char* json = NULL;

  List* tempList = (List*)list;
  //checks if its valid to be turned to a string
  if(tempList && getLength(tempList) != 0){
    //buffer for ints no int is big enough to overflow it
    ListIterator ittr = createIterator(tempList);
    void* value;
    //gets the attr string
    char* attrString = NULL;
    json = malloc(sizeof(char)*2);
    strcpy(json,"[");
    while((value = nextElement(&ittr)) != NULL){
        attrString = attrToJSON(value);
        json = realloc(json,sizeof(char)*(strlen(json) + strlen(attrString) + 2));
        strcat(json,attrString);
        strcat(json,",");
        free(attrString);
    }
    json[strlen(json)-1] = ']';

  } else{ //not valid
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"[]");
  }

  return json;
}

/** Function to converting a list of Circle structs into a JSON string
*@pre Circle list is not NULL
*@post Circle list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* circListToJSON(const List *list){
  char* json = NULL;

  List* tempList = (List*)list;
  //checks if its valid to be turned to a string
  if(tempList && getLength(tempList) != 0){
    //buffer for ints no int is big enough to overflow it
    ListIterator ittr = createIterator(tempList);
    void* value;
    //gets the attr string
    char* attrString = NULL;
    json = malloc(sizeof(char)*2);
    strcpy(json,"[");
    while((value = nextElement(&ittr)) != NULL){
        attrString = circleToJSON(value);
        json = realloc(json,sizeof(char)*(strlen(json) + strlen(attrString) + 2));
        strcat(json,attrString);
        strcat(json,",");
        free(attrString);
    }
    json[strlen(json)-1] = ']';

  } else{ //not valid
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"[]");
  }

  return json;
}

/** Function to converting a list of Rectangle structs into a JSON string
*@pre Rectangle list is not NULL
*@post Rectangle list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* rectListToJSON(const List *list){
  char* json = NULL;

  List* tempList = (List*)list;
  //checks if its valid to be turned to a string
  if(tempList && getLength(tempList) != 0){
    //buffer for ints no int is big enough to overflow it
    ListIterator ittr = createIterator(tempList);
    void* value;
    //gets the attr string
    char* attrString = NULL;
    json = malloc(sizeof(char)*2);
    strcpy(json,"[");
    while((value = nextElement(&ittr)) != NULL){
        attrString = rectToJSON(value);
        json = realloc(json,sizeof(char)*(strlen(json) + strlen(attrString) + 2));
        strcat(json,attrString);
        strcat(json,",");
        free(attrString);
    }
    json[strlen(json)-1] = ']';

  } else{ //not valid
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"[]");
  }

  return json;
}

/** Function to converting a list of Path structs into a JSON string
*@pre Path list is not NULL
*@post Path list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* pathListToJSON(const List *list){
  char* json = NULL;
  List* tempList = (List*)list;
  //checks if its valid to be turned to a string
  if(tempList && getLength(tempList) != 0){
    //buffer for ints no int is big enough to overflow it
    ListIterator ittr = createIterator(tempList);
    void* value;
    //gets the attr string
    char* attrString = NULL;
    json = malloc(sizeof(char)*2);
    strcpy(json,"[");
    while((value = nextElement(&ittr)) != NULL){
        attrString = pathToJSON(value);
        json = realloc(json,sizeof(char)*(strlen(json) + strlen(attrString) + 2));
        strcat(json,attrString);
        strcat(json,",");
        free(attrString);
    }
    json[strlen(json)-1] = ']';

  } else{ //not valid
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"[]");
  }

  return json;
}

/** Function to converting a list of Group structs into a JSON string
*@pre Group list is not NULL
*@post Group list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* groupListToJSON(const List *list){
  char* json = NULL;
  List* tempList = (List*)list;
  //checks if its valid to be turned to a string
  if(tempList && getLength(tempList) != 0){
    //buffer for ints no int is big enough to overflow it
    ListIterator ittr = createIterator(tempList);
    void* value;
    //gets the attr string
    char* attrString = NULL;
    json = malloc(sizeof(char)*2);
    strcpy(json,"[");
    while((value = nextElement(&ittr)) != NULL){
        attrString = groupToJSON(value);
        json = realloc(json,sizeof(char)*(strlen(json) + strlen(attrString) + 2));
        strcat(json,attrString);
        strcat(json,",");
        free(attrString);
    }
    json[strlen(json)-1] = ']';

  } else{ //not valid
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"[]");
  }

  return json;
}

/** Function to converting an SVGimage into a JSON string
*@pre SVGimage is not NULL
*@post SVGimage has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to an SVGimage struct
**/
char* SVGtoJSON(const SVGimage* image){
  SVGimage* tempImage = (SVGimage*)image;
  char* json = NULL;
  if(tempImage){
    //buffers to hold numbers note its not possible to have a int over 1000 chars
    //so it is safe to use static strings
    char numR[1000];
    char numC[1000];
    char numP[1000];
    char numG[1000];

    //length of rects
    List* list = getRects(tempImage);
    sprintf(numR,"%d",getLength(list));
    freeList(list);

    //length of circles
    list = getCircles(tempImage);
    sprintf(numC,"%d",getLength(list));
    freeList(list);

    //length of paths
    list = getPaths(tempImage);
    sprintf(numP,"%d",getLength(list));
    freeList(list);

    //length of groups
    list = getGroups(tempImage);
    sprintf(numG,"%d",getLength(list));
    freeList(list);

    //mallocs space and prints it to the string
    json = malloc(sizeof(char)*(strlen("{\"numRect\":,\"numCirc\":,\"numPaths\":,\"numGroups\":}")
                              + strlen(numR) + strlen(numC) + strlen(numP) + strlen(numG) + 1));
    sprintf(json,"{\"numRect\":%s,\"numCirc\":%s,\"numPaths\":%s,\"numGroups\":%s}",numR,numC,numP,numG);

  }  else{ //not valid return return empty string
    json = malloc(sizeof(char) * (strlen("{}") + 1));
    strcpy(json,"{}");
  }

  return json;

}

/* ******************************* Bonus A2 functions - optional for A2 *************************** */

/** Function to converting a JSON string into an SVGimage struct
*@pre JSON string is not NULL
*@post String has not been modified in any way
*@return A newly allocated and initialized SVGimage struct
*@param str - a pointer to a string
**/
SVGimage* JSONtoSVG(const char* svgString){
  SVGimage* img = NULL;
  if(svgString){
    JsonAttr* json = parseJSONString(svgString);
    if(json){
      JsonAttr* temp;
      //creates and sets the value to the image
      img = malloc(sizeof(SVGimage));
      initImage(img);
      strcpy(img->namespace,"http://www.w3.org/2000/svg");

      //runs though the linked list getting values from it*/
      do{
        if(strcmp(json->name,"title") == 0){ //gets the title attribute
          strncpy(img->title,json->value,255);
          img->title[255] = '\0';

      } else if(strcmp(json->name,"descr") == 0){ //gets the description
          strncpy(img->description,json->value,255);
          img->description[255] = '\0';

        }
        //frees the list
        temp = json->next;
        free(json->name);
        free(json->value);
        free(json);
      }while((json = temp) != NULL);
    }
  }
  return img;
}

/**parses a jSON string and returns the value as a linked list
 *@JsonString a string that represents a JSON
 *@return a struct holding the values of the Json
*/
JsonAttr* parseJSONString(const char* JsonString){
  JsonAttr* list = NULL;
  //makes sure it exists and that it has an open and close brace
  if(JsonString && *JsonString == '{' && JsonString[strlen(JsonString)-1] == '}'){
    //checks if its a name or a value
    int isName = 1;
    //checks if its in a quote or not
    int inQuote = 0;

    //checks if the Json is valid
    bool isValid = true;
    //holds the value
    list = malloc(sizeof(JsonAttr));

    list->next = NULL;
    list->value = malloc(sizeof(char));
    list->value[0] = '\0';
    list->name = malloc(sizeof(char));
    list->name[0] = '\0';

    char** temp;
    for(int i = 1; i < strlen(JsonString)-1; i++){

      //if it enters a quote and its not an escape character it enters quotes
      if(JsonString[i] == '\"' && JsonString[i-1] != '\\' ){
        inQuote = inQuote ? 0 : 1; //swaps the value of inquote
      } else if(JsonString[i] == ':' && inQuote == 0) { //now getting the value
          if(JsonString[i-1] == ':'  || JsonString[i-1] == ','){ //make sure its a valid place to put a value
              isValid = false;
              break;
          }
        isName = 0;
      } else if(JsonString[i] == ',' && inQuote == 0){ //now getting the name
        if(JsonString[i-1] == ':'  || JsonString[i-1] == ','){
            isValid = false;
            break;
        }
        isName = 1;
        //mallocs room for another value
        JsonAttr* tempJson = malloc(sizeof(JsonAttr));
        tempJson->next = list;
        list = tempJson;
        list->value = malloc(sizeof(char));
        list->value[0] = '\0';
        list->name = malloc(sizeof(char));
        list->name[0] = '\0';
    } else if(!inQuote &&  !(isdigit(JsonString[i])  || JsonString[i] == '-' || JsonString[i] == '.')){ //can only have numbers , '.' and '-'  out side of quotes
        isValid = false;
        break;
    }else { //append to the end of the string.
        temp = (isName) ? &(list->name) : &(list->value);
        *temp = realloc(*temp,sizeof(char)*(strlen(*temp)+2));
        (*temp)[strlen(*temp)+1] = '\0';
        (*temp)[strlen(*temp)] = JsonString[i];

      }

    }

    //if found that its invalid or it exits and it thinks its in  a quote its invalid
    if(!isValid || inQuote){
        //frees list
        JsonAttr* tempJson;
        while(list != NULL){
            tempJson = list->next;
            free(list->name);
            free(list->value);
            free(list);
            list = tempJson;
        }
    }
  }
  return list;
}

/** Function to converting a JSON string into a Rectangle struct
*@pre JSON string is not NULL
*@post Rectangle has not been modified in any way
*@return A newly allocated and initialized Rectangle struct
*@param str - a pointer to a string
**/
Rectangle* JSONtoRect(const char* svgString){
    Rectangle* rect = NULL;
    bool isValid = true;
    if(svgString){
      JsonAttr* json = parseJSONString(svgString);
      bool xFound = false;
      bool yFound = false;
      bool wFound = false;
      bool hFound = false;
      bool unitsFound = false;
      if(json){
        JsonAttr* temp;
        //creates and sets the value to the image
        rect = malloc(sizeof(Rectangle));
        rect->x = 0;
        rect->y = 0;
        rect->width = 0;
        rect->height = 0;
        *(rect->units) = '\0';

        rect->otherAttributes = initializeList(attributeToString,deleteAttribute,compareAttributes);

        //runs though the linked list getting values from it*/
        do{
          if(!isValid){
              //do nothing but this means rect is not valid
          } else if(strcmp(json->name,"x") == 0){ //gets x attribute
             if(!xFound){
                 sscanf(json->value,"%f",&(rect->x));
                 xFound = true;
             } else{ //x already found thus json is false
                 isValid = false;
             }

        } else if(strcmp(json->name,"y") == 0){ //gets y attribute
            if(!yFound){
                sscanf(json->value,"%f",&(rect->y));
                yFound = true;
            } else{ //y already found json isnt valid.
                isValid = false;
            }
        }else if(strcmp(json->name,"w") == 0){ //gets width attribute
            if(!wFound){
                sscanf(json->value,"%f",&(rect->width));
                wFound = true;
            } else { //width already found invalid Json
                isValid = false;
            }
        }else if(strcmp(json->name,"h") == 0){ //gets hieght attribute
            if(!hFound){
                sscanf(json->value,"%f",&(rect->height));
                hFound = true;
            } else {
                isValid = false;
            }

        } else if(strcmp(json->name,"units") == 0){ //gets unit attribute
            if(!unitsFound){
               strncpy(rect->units,json->value,50);
               rect->units[49] = '\0';
               unitsFound = true;
           } else { //already found no longer valid
               isValid = false;
           }
       } else { //invalid attribute no longer valid
            isValid = false;
        }
          //frees the list
          temp = json->next;
          free(json->name);
          free(json->value);
          free(json);
        }while((json = temp) != NULL);
      }

      //checks if all attributes are found
      if(!xFound || !yFound || !wFound || !hFound || !unitsFound) isValid = false;
      //frees struct if its not valid
      if(!isValid || !checkRects(rect)){
          deleteRectangle(rect);
          rect = NULL;
      }
    }
    return rect;
}

/** Function to converting a JSON string into a Circle struct
*@pre JSON string is not NULL
*@post Circle has not been modified in any way
*@return A newly allocated and initialized Circle struct
*@param str - a pointer to a string
**/
Circle* JSONtoCircle(const char* svgString){
    Circle* circle = NULL;
    if(svgString){
      JsonAttr* json = parseJSONString(svgString);
      if(json){
        //Used to make sure all objects were found
        bool xFound = false;
        bool yFound = false;
        bool rFound = false;
        bool unitsFound = false;
        //holds if the json is still valid
        bool isValid = true;
        JsonAttr* temp;
        //creates and sets the value to the image
        circle = malloc(sizeof(Circle));
        circle->cx = 0;
        circle->cy = 0;
        circle->r = 0;
        *(circle->units) = '\0';
        circle->otherAttributes = initializeList(attributeToString,deleteAttribute,compareAttributes);

        //runs though the linked list getting values from it
        do{
            //checks if the image is still valid
            if(!isValid){
                //do nothing just has to run though the list to free the queue
            }
            else if(strcmp(json->name,"cx") == 0){ //gets x attribute
              if(!xFound){ //cx has not been found.
                sscanf(json->value,"%f",&(circle->cx));
                xFound = true;
            } else{
                isValid = false;
            }
            } else if(strcmp(json->name,"cy") == 0){ //gets y attribute
                if(!yFound){
                    sscanf(json->value,"%f",&(circle->cy));
                    yFound = true;
                //no longer valid
                } else isValid = false;

            }else if(strcmp(json->name,"r") == 0){ //gets hieght attribute
                if(!rFound){
                    sscanf(json->value,"%f",&(circle->r));
                    rFound = true;
                } else isValid = false;

            } else if(strcmp(json->name,"units") == 0){ //gets unit attribute
                if(!unitsFound){
                    strncpy(circle->units,json->value,50);
                    circle->units[49] = '\0';
                    unitsFound = true;
                } else isValid = false;
           }
           //frees the list
           temp = json->next;
           free(json->name);
           free(json->value);
           free(json);
        }while((json = temp) != NULL);

        //checks if all attributes are found
        if(!xFound || !yFound || !rFound || !unitsFound) isValid = false;
        //frees struct if its not valid
        if(!isValid || !checkCircles(circle)){
            deleteCircle(circle);
            circle = NULL;
        }
      }

    }
    return circle;
}

/******************************************************** A2 stuff ********************************/


/** Function to create an SVG object based on the contents of an SVG file.
 *@pre File name cannot be an empty string or NULL.
       File represented by this name must exist and must be readable.
 *@post Either:
        A valid SVGimage has been created and its address was returned
		or
		An error occurred, and NULL was returned
 *@return the pinter to the new struct or NULL
 *@param fileName - a string containing the name of the SVG file
**/
SVGimage* createSVGimage(char* fileName){

    xmlDoc* doc = NULL;
    xmlNode* rootNode = NULL;
    SVGimage* img = NULL;
    //init the library
    LIBXML_TEST_VERSION

    /*parse the file and get the DOM */
    doc = xmlReadFile(fileName, NULL, 0);
    rootNode = xmlDocGetRootElement(doc);

    /* if the doc was read correcetly malloc memory for image
     * then parses the XML into the image*/
    if(doc){
        img = malloc(sizeof(SVGimage));
        initImage(img);
        parseXML(img,rootNode);

    }

    /*free the document */
    xmlFreeDoc(doc);

    /*
     *Free the global variables that may
     *have been allocated by the parser.
     */
    xmlCleanupParser();

    return img;
}



/** Function to delete image content and free all the memory.
 *@pre SVGimgage  exists, is not null, and has not been freed
 *@post SVSVGimgageG  had been freed
 *@return none
 *@param obj - a pointer to an SVG struct
**/
void deleteSVGimage(SVGimage* img){
    //TODO FREE Data
    if(img){
      freeList(img->rectangles);
      freeList(img->paths);
      freeList(img->groups);
      freeList(img->otherAttributes);
      freeList(img->circles);
      free(img);
    }
}

/** Function to create a string representation of an SVG object.
 *@pre SVGimgage exists, is not null, and is valid
 *@post SVGimgage has not been modified in any way, and a string representing the SVG contents has been created
 *@return a string contaning a humanly readable representation of an SVG object
 *@param obj - a pointer to an SVG struct
**/
char* SVGimageToString(SVGimage* img){
    //Holds the string reperenstation of the image
    char* imageString = NULL;
    char* tempString = NULL;

    //makes sure the image exists
    if(img){
        //general image info
        //mallocs enough for general info
        imageString = malloc(sizeof(char)*(73 + strlen(img->namespace) +
                                                strlen(img->title) +
                                                strlen(img->description)
                                            ));

        strcpy(imageString, "IMAGE STRING\n\n");
        strcat(imageString, "Namespace: ");
        strcat(imageString, img->namespace);
        strcat(imageString, "\nTitle: ");
        strcat(imageString, img->title);
        strcat(imageString, "\nDescription: ");
        strcat(imageString, img->description);
        strcat(imageString, "\n\n");


        //prints the rectangles
        strcat(imageString, "RECTANGLES\n");
        strcat(imageString, "----------");
        tempString = toString(img->rectangles);
        if(tempString){ //if the string exists reallocs enough space for it plus next string

            imageString = realloc(imageString, (strlen(imageString)+1 + strlen(tempString)));
            strcat(imageString,tempString);
            free(tempString); //Must be set to null for next obj
            tempString = NULL;
        }



        imageString = realloc(imageString, sizeof(char)*(strlen(imageString)+18));
        //prints cirlces
        strcat(imageString,"\n\nCIRCLES\n");
        strcat(imageString,"-------");
        tempString = toString(img->circles);
        if(tempString){ //if the string exists reallocs enough space for it plus next string

          imageString = realloc(imageString, (strlen(imageString)+1 + strlen(tempString)) );
          strcat(imageString,tempString);
          free(tempString);
          tempString = NULL;  //Must be set to null for next obj
        }

        imageString = realloc(imageString, sizeof(char)*(strlen(imageString)+14));
        //prints all paths
        strcat(imageString,"\n\nPATHS\n");
        strcat(imageString, "-----");
        tempString = toString(img->paths);
        if(tempString){ //if the string exists reallocs enough space for it plus next string

          imageString = realloc(imageString, (strlen(imageString)+1 + strlen(tempString)) );
          strcat(imageString,tempString);
          free(tempString);
          tempString = NULL;  //Must be set to null for next obj
        }

        imageString = realloc(imageString, sizeof(char)*(strlen(imageString)+16));
        //prints all groups
        strcat(imageString, "\n\nGROUPS\n");
        strcat(imageString, "------");
        tempString = toString(img->groups);
        if(tempString){ //if the string exists reallocs enough space for it plus next string

          imageString = realloc(imageString, (strlen(imageString)+1 + strlen(tempString)) );
          strcat(imageString,tempString);
          free(tempString);
          tempString = NULL;  //Must be set to null for next obj
        }


        //all other attributes and its content
        imageString = realloc(imageString, sizeof(char)*(strlen(imageString)+37));
        strcat(imageString, "\n\nOTHER-ATTRIBUTES\n");
        strcat(imageString, "----------------");
        tempString = toString(img->otherAttributes);
        if(tempString){ //if the string exists reallocs enough space no room need for next string

          imageString = realloc(imageString, sizeof(char)*(strlen(imageString)+1 + strlen(tempString)) );
          strcat(imageString,tempString);
          free(tempString);
        }

    }
    return imageString;
}

void initImage(SVGimage* img){

    if(!img){
      return;
    }
    //makes sure all the strings are empty to start
    img->namespace[0] = '\0';
    img->title[0] = '\0';
    img->description[0] = '\0';

    //init lists
    img->rectangles = initializeList(rectangleToString,deleteRectangle,compareRectangles);
    img->circles = initializeList(circleToString,deleteCircle,compareCircles);
    img->paths = initializeList(pathToString,deletePath,comparePaths);
    img->groups = initializeList(groupToString,deleteGroup,compareGroups);
    img->otherAttributes = initializeList(attributeToString,deleteAttribute,compareAttributes);

}


/**Helper functions for svg images*/

/*Deletes a passed in Atribute
 *@param data an attributes
 */
void deleteAttribute( void* data){
    if(data != NULL){ //makes sure it doesn't free a NULL ptr
        Attribute* attr = (Attribute*)data;
        if(attr->name != NULL)free(attr->name);
        if(attr->value != NULL)free(attr->value);
        free(attr);
    }
}

/*Takes in an attribute and returns a malloced string
 *@param data an attribute
 *@return malloced string reperenstation
 */
char* attributeToString( void* data){
  Attribute* attr = (Attribute*)data;
  char* string = NULL;

  if(attr && attr->name && attr->value){
      string = malloc(sizeof(char)*(strlen("\t--Attribute-- :")+1)+
        strlen(attr->name) +strlen(attr->value)
      ); //gets size for init string
      strcpy(string,"\t--Attribute-- ");
      strcat(string,attr->name);
      strcat(string,":");
      strcat(string,attr->value);


  }
  return string;
}

/*Does nothing*/
int compareAttributes(const void *first, const void *second){
  return 0;
}
/**deletes group from data
 *@param data a group struct
 */
void deleteGroup(void* data){
  Group* group = (Group*)data;
  if(group){ //if groups exists free
      freeList(group->rectangles);
      freeList(group->circles);
      freeList(group->paths);
      freeList(group->groups);
      freeList(group->otherAttributes);
      free(group);
  }
}

/**returns a string reperenstation of a group
 *@param data a group structs
 *@return returns a string version of groups*/
char* groupToString( void* data){
  char* string;
  char* rectangleString;
  char* circleString;
  char* pathString;
  char* groupString;
  char* otherAttrString;
  Group* group = (Group*)data;

  //if valid group is given
  if(data){
    //get All the groups as strings
    rectangleString = toString(group->rectangles);
    circleString = toString(group->circles);
    pathString = toString(group->paths);
    otherAttrString = toString(group->otherAttributes);
    groupString = toString(group->groups);

    //mallocs room for all the strings and flavour text
    string = malloc(sizeof(char)*(strlen(rectangleString) +
                                  strlen(circleString)    +
                                  strlen(pathString)      +
                                  strlen(otherAttrString) +
                                  strlen(groupString)     +
                                  strlen("\n--GROUP ATTRIBUTES--") +
                                  strlen("\n--GROUP START--") +
                                  strlen("\n--GROUP END--") + 1));

    //copy and cat all strings into one.
    strcpy(string,"\n--GROUP START--");
    strcat(string,rectangleString);
    strcat(string,circleString);
    strcat(string,pathString);
    strcat(string, "\n--GROUP ATTRIBUTES--");
    strcat(string,otherAttrString);
    strcat(string,groupString);
    strcat(string,"\n--GROUP END--");

    //free all strings
    free(rectangleString);
    free(circleString);
    free(pathString);
    free(otherAttrString);
    free(groupString);

  }

  return string;
}

/*Does nothing*/
int compareGroups(const void *first, const void *second){
  return 0;
}

//delets retangles
void deleteRectangle(void* data){
  if(data){
    freeList(((Rectangle*)data)->otherAttributes);
    free(data);
  }

}

//returns retangles as string that have to be freed
char* rectangleToString(void* data){
  char* string = NULL;
  char buffer[1000]; //buffer for numbers
  buffer[0] = '\0';
  char* AttributesString = NULL;
  Rectangle* rect = (Rectangle*)data;
  if(data){
    string = malloc(sizeof(char)*(1+ strlen("\n\tRectangle: \n\tX: ")));

    strcpy(string,"\n\tRectangle: \n\t");

    //X
    strcat(string,"X: ");
    snprintf(buffer,1000,"%.2f",rect->x);
    string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(buffer) + strlen("\n\tY: ")));
    strcat(string,buffer);

    //Y
    strcat(string,"\n\tY: ");
    snprintf(buffer,1000,"%.2f",rect->y);
    string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(buffer) + strlen("\n\tWidth: ")));
    strcat(string,buffer);

    //width
    strcat(string,"\n\tWidth: ");
    snprintf(buffer,1000,"%.2f",rect->width);
    string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(buffer) + strlen("\n\tHeight: ")));
    strcat(string,buffer);

    //height
    strcat(string,"\n\tHeight: ");
    snprintf(buffer,1000,"%.2f",rect->height);
    string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(buffer) + strlen(rect->units) + strlen("\n\tUnits: ")));
    strcat(string,buffer);

    //units
    strcat(string,"\n\tUnits: ");
    strcat(string,rect->units);

    //otherAttributes
    AttributesString = toString(rect->otherAttributes);
    if(AttributesString)
    {
      string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(AttributesString)));
      strcat(string,AttributesString);
      free(AttributesString);
    }
  }

  return string;

}

//does nothing
int compareRectangles(const void *first, const void *second){
  return 0;
}


//frees a circle taken in
void deleteCircle(void* data){
  if(data){
    Circle* circle = (Circle*)data;
    freeList(circle->otherAttributes);
    free(circle);
  }
}

//converts a circle to a string
char* circleToString(void* data){
  char* string = NULL;
  char buffer[1000]; //buffer for numbers
  buffer[0] = '\0';
  char* AttributesString = NULL;
  Circle* circle = (Circle*)data;
  if(data){
    string = malloc(sizeof(char)*(1+ strlen("\n\tCircle: \n\tCX: ")));

    strcpy(string,"\n\tCircle: \n\t");

    //CX
    strcat(string,"CX: ");
    snprintf(buffer,1000,"%.2f",circle->cx);
    string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(buffer) + strlen("\n\tCY: ")));
    strcat(string,buffer);

    //Y
    strcat(string,"\n\tCY: ");
    snprintf(buffer,1000,"%.2f",circle->cy);
    string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(buffer) + strlen("\n\tWidth: ")));
    strcat(string,buffer);

    //width
    strcat(string,"\n\tR: ");
    snprintf(buffer,100,"%.2f",circle->r);
    string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(buffer) + strlen(circle->units) + strlen("\n\tUnits: ")));
    strcat(string,buffer);

    //units
    strcat(string,"\n\tUnits: ");
    strcat(string,circle->units);

    //otherAttributes
    AttributesString = toString(circle->otherAttributes);
    if(AttributesString)
    {
      string = realloc(string,sizeof(char)*(strlen(string)+1+strlen(AttributesString)));
      strcat(string,AttributesString);
      free(AttributesString);
    }
  }

  return string;
}

//does nothing
int compareCircles(const void *first, const void *second){
  return 0;
}


//deletes a path
void deletePath(void* data){
  Path* path = (Path*)data;
  if(path){
    if(path->otherAttributes){
      freeList(path->otherAttributes);
      path->otherAttributes = NULL;
    }
    if(path->data){
      free(path->data);
      path->data = NULL;
    }
    free(path);

  }
}

//converts a path to a string that has to be freed
char* pathToString(void* data){
  Path* path = (Path*)data;
  char* string = NULL;
  char* otherAttrString = NULL;
  long lengthOfAttr = 0;

  if(path){
      otherAttrString = toString(path->otherAttributes);
      lengthOfAttr = strlen(otherAttrString);
      string = malloc(sizeof(char)*( 1 + strlen("\n\tPath: \n") + lengthOfAttr +
                                          strlen(path->data)));

      //path info
      strcpy(string,"\n\tPath: ");
      strcat(string,path->data);

      //otherAttributes

      //AtributeInfo
      strcat(string, otherAttrString);
      free(otherAttrString);
  }

  return string;
}

//does nothing
int comparePaths(const void *first, const void *second){
  return 0;
}

//empty function for deleting list without deleting data
void deleteNode(void* data){

}


// Function that returns the number of all rectangles with the specified area
int numRectsWithArea(SVGimage* img, float area){
  List* rects;
  ListIterator listIterator;
  void* value;
  int count = 0; //holds how many rects are found of the same width

  if(img){
    rects = getRects(img);
    listIterator = createIterator(rects);
    //goes through all rects finding the area and flooring them
    while((value = nextElement(&listIterator)) != NULL){
      if(ceil(((Rectangle*)value)->width * ((Rectangle*)value)->height) == ceil(area)){
        count++;

      }
    }
    freeList(rects);
  }



  return count;
}
// Function that returns the number of all circles with the specified area
int numCirclesWithArea(SVGimage* img, float area){
  List* circles;
  ListIterator listIterator;
  void* value;
  int count = 0; //holds how many cirlce are found of the same area

  if(img){
    circles = getCircles(img);
    listIterator = createIterator(circles);

    //goes through all circles finding the area and flooring them
    while((value = nextElement(&listIterator)) != NULL){
      if(ceil(((Circle*)value)->r * ((Circle*)value)->r * PI) == ceil(area)){
        count++;
      }

    }

    freeList(circles);
  }

  return count;
}
// Function that returns the number of all paths with the specified data - i.e. Path.data field
int numPathsWithdata(SVGimage* img, char* data){
  List* paths;
  ListIterator listIterator;
  void* value;
  int count = 0; //holds how many paths are found of the data

  if(img){
    paths = getPaths(img);
    listIterator = createIterator(paths);
    //goes through all paths with the same data values
    while((value = nextElement(&listIterator)) != NULL){
      if(strcmp(((char*)((Path*)value)->data),data) == 0){
        count++;
      }
    }
    freeList(paths);

  }

  return count;
}
// Function that returns the number of all groups with the specified length - see A1 Module 2 for details
int numGroupsWithLen(SVGimage* img, int len){
  List* groups;
  ListIterator listIterator;
  void* value;
  int nodeLength = 0;
  int count = 0; //holds how many paths are found of the data
  Group* group;
  if(img){
    groups = getGroups(img);
    listIterator = createIterator(groups);
    //goes through all paths with the same data values
    while((value = nextElement(&listIterator)) != NULL){
      group = (Group*)value;
      nodeLength = 0;
      nodeLength += getLength(group->rectangles);
      nodeLength += getLength(group->circles);
      nodeLength += getLength(group->paths);
      nodeLength += getLength(group->groups);

      if(nodeLength == len){
        count++;
      }

    }

    freeList(groups);
  }


  return count;
}


/*  Function that returns the total number of Attribute structs in the SVGimage - i.e. the number of Attributes
    contained in all otherAttributes lists in the structs making up the SVGimage
    *@pre SVGimgage  exists, is not null, and has not been freed.
    *@post SVGimage has not been modified in any way
    *@return the total length of all attribute structs in the SVGimage
    *@param obj - a pointer to an SVG struct
*/
int numAttr(SVGimage* img){

  if(!img) return 0;
  //iterator to go though groups
  ListIterator listIterator;

  //the list used to get the number of attributes
  List* rectList = getRects(img);
  List* circleList = getCircles(img);
  List* pathList =getPaths(img);
  List* groupList = getGroups(img);
  int count = getLength(img->otherAttributes);
  void* value;


  //rectangles
  listIterator = createIterator(rectList);
  while((value = nextElement(&listIterator)) != NULL){
    count+= getLength(((Rectangle*)value)->otherAttributes);
  }

  //circle
  listIterator = createIterator(circleList);
  while((value = nextElement(&listIterator)) != NULL){
    count+= getLength(((Circle*)value)->otherAttributes);
  }

  //path
  listIterator = createIterator(pathList);
  while((value = nextElement(&listIterator)) != NULL){

      count+= getLength(((Path*)value)->otherAttributes);
  }

  //group
  listIterator = createIterator(groupList);
  while((value = nextElement(&listIterator)) != NULL){
    count+= getLength(((Group*)value)->otherAttributes);
  }

  freeList(pathList);
  freeList(circleList);
  freeList(rectList);
  freeList(groupList);
  return count;



}

// Function that returns a list of all rectangles in the image.
List* getRects(SVGimage* img){
  List* list = NULL;
  ListIterator listIterator;;
  List* groups;
  ListIterator groupIterator;;
  void* value;
  Group* group;
  if(img){
    list = initializeList(rectangleToString,deleteNode,compareRectangles);
    listIterator = createIterator(img->rectangles);
    groups = getGroups(img);
    groupIterator = createIterator(groups);
    //itterates though the main image and grabs all paths in the root of the image

    while((value = nextElement(&listIterator)) != NULL){
      if(value){
        insertBack(list,value);
      }
    }
    //go though groups and then go though all path in group
    while((group = (Group*)nextElement(&groupIterator)) != NULL){
      listIterator = createIterator(group->rectangles);
      while((value = nextElement(&listIterator)) != NULL){
        if(value){
          insertBack(list,value);
        }
      }

    }
    freeList(groups);
  }

  return list;
}
// Function that returns a list of all circles in the image.
List* getCircles(SVGimage* img){
  List* list = NULL;
  ListIterator listIterator;
  List* groups;
  ListIterator groupIterator;
  void* value;
  Group* group;

  if(img){
    //itterates though the main image and grabs all paths in the root of the image
    list = initializeList(circleToString,deleteNode,compareCircles);
    listIterator = createIterator(img->circles);
    groups = getGroups(img);
    groupIterator = createIterator(groups);

    while((value = nextElement(&listIterator)) != NULL){
      if(value){
        insertBack(list,value);
      }
    }
    //go though groups and then go though all path in group
    while((group = (Group*)nextElement(&groupIterator)) != NULL){
      listIterator = createIterator(group->circles);
      while((value = nextElement(&listIterator)) != NULL){
        if(value){
          insertBack(list,value);
        }
      }

    }

    freeList(groups);
  }
  return list;
}
// Function that returns a list of all groups in the image.
List* getGroups(SVGimage* img){
  List* list = NULL;
  ListIterator listIterator;

  void* value;


  //itterates though the main image and grabs all paths in the root of the image

  if(img){
    list = initializeList(groupToString,deleteNode,compareGroups);
    listIterator = createIterator(img->groups);
    while((value = nextElement(&listIterator)) != NULL){
      if(value){
        insertBack(list,value);
      }
      getGroupsFromGroups(list,(Group*)value);
    }
  }




  return list;
}


// Function that returns a list of all paths in the image.
List* getPaths(SVGimage* img){
  List* list = NULL;
  ListIterator listIterator;
  List* groups;
  ListIterator groupIterator;
  void* value;
  Group* group;
  //itterates though the main image and grabs all paths in the root of the image

  if(img){
    list = initializeList(pathToString,deleteNode,comparePaths);
    listIterator = createIterator(img->paths);
    groups = getGroups(img);
    groupIterator = createIterator(groups);
    while((value = nextElement(&listIterator)) != NULL){
      if(value){
        insertBack(list,value);
      }
    }
    //TODO
    //go though groups and then go though all path in group
    while((group = (Group*)nextElement(&groupIterator)) != NULL){
      listIterator = createIterator(group->paths);
      while((value = nextElement(&listIterator)) != NULL){
        if(value){
          insertBack(list,value);
        }
      }

    }
    freeList(groups);
  }

  return list;
}



/***********************UTIL FUNCTION***********************/


/**Checks if a list is valid by traversing through it and using the given checker function to test it
 *@pre list is a valid list
 *@param list the given list that will be checked
 *@checker will be used to test the given elements in the list ie for circles checkCircles should be passed
 *@return true if valid false if not valid
*/
bool isListValid(const List* list, bool (*checker)(const void*)){
    ListIterator listIterator;
    void* value;
    List* tempList = (List*)list;
    bool isValid = false; //return value if true list is valid if false it is invalid
    if(list){
      isValid = true;
      listIterator = createIterator(tempList);
      //goes through all attributes adding them to the node
      while((value = nextElement(&listIterator)) != NULL){
        //checks if the element is valid
        if(!checker(value)) isValid = false;
      }
    }

    return isValid;


}

//checker functions for objects will be passed into isListValid function as checker
bool checkRects(const void* element){
    Rectangle* rect = (Rectangle*) element;
    bool isValid = true;

    //if the element is null we not it isnt value;
    if(!element) return false;

    //checks other features
    if(rect->width < 0 || rect->height < 0){
        isValid = false;
    }
    if(!rect->otherAttributes){
        isValid = false;
    }else{
        if(isValid) isValid = isListValid(rect->otherAttributes,checkAttribute);
    }
    return isValid;
}
bool checkCircles(const void* element){
    Circle* circle = (Circle*) element;
    bool isValid = true;

    //if the element is null we not it isnt value;
    if(!element) return false;

    if(circle->r < 0){
        isValid = false;
    }
    if(!circle->otherAttributes){
        isValid = false;
    }else{
        if(isValid) isValid = isListValid(circle->otherAttributes,checkAttribute);
    }

    return isValid;
}
bool checkPaths(const void* element){
    Path* path = (Path*) element;
    bool isValid = true;

    //if the element is null we not it isnt value;
    if(!element) return false;

    if(!path->data){
        isValid = false;
    }
    if(!path->otherAttributes){
        isValid = false;
    }else{
        if(isValid) isValid = isListValid(path->otherAttributes,checkAttribute);
    }
    return isValid;
}
bool checkGroups(const void* element){
    Group* group = (Group*) element;
    bool isValid = true;
    //if the element is null we not it isnt value;
    if(!element) return false;

    if(!group->rectangles || !group->circles || !group->paths || !group->groups){
        isValid = false;
    }
    if(!group->otherAttributes){
        isValid = false;
    }else{
        if(isValid) isValid = isListValid(group->otherAttributes,checkAttribute);
    }
    return isValid;
}

bool checkAttribute(const void* element){
    if(!element) return false;

    Attribute* attr = (Attribute*)element;

    if(attr->name && attr->value){
        return true;
    } else{
        return false;
    }
}

/**takes in a quantity as a string and returns it as a struct
 *@pre if a NULL string is given will return null. assuming string is valid
 *@param num the quantity being parsed
 *@return the quantity as a struct*/
Quantity* parseNumber(char* num){
  char* value = NULL;
  Quantity* quantity = NULL;
  int isUnit = 0; //flag for when to only append to unit.
  if(num){
    //malloc for one char and set it to the null so length is 0
    value = malloc(sizeof(char));
    *value = '\0';

    //create quantity
    quantity = malloc(sizeof(Quantity));
    quantity->unit[0] = '\0';

    //parse quantity
    for(;*num!='\0';num++){ //only append to number if isUnit is false.
      if((isdigit(*num) || *num == '.' || (*num == '-' && *value == '\0')) && !isUnit){ //concat digit on to end of value;
        value = realloc(value,sizeof(char)*(strlen(value)+2));
        value[strlen(value)+1] = '\0'; //add new null terminator
        value[strlen(value)] = *num; //append new value;
      } else{ //append to unit
        isUnit = 1;
        strncat(quantity->unit,num,1); //appends one character
      }
    }
    sscanf(value,"%f",&(quantity->value)); //copies value into the quantity value
  }
  //if value exits free it
  if(value) free(value);

  return quantity;
}

/**sets values from a quantity to its units and value
 *@pre nothing can be null
 *@param quantity being info is stored in  :: intent in
 *@param units the units gotten from the quantity
 *@param value the value quantity value is being stored in.
 */
void setAttributeValue(Quantity* quantity,char* units,float* value){
  if(strlen(quantity->unit) > 0 && strlen(units) == 0){
    strcpy(units,quantity->unit);
  }
  *value =  quantity->value;
}

/**creates a new group object must be freed when done with.
  *@return Group* a newly malloced group;
  */
Group* initGroup(){
  Group* newGroup;
  newGroup = malloc(sizeof(Group));
  newGroup->rectangles = initializeList(rectangleToString,deleteRectangle,compareRectangles);
  newGroup->circles = initializeList(circleToString,deleteCircle,compareCircles);
  newGroup->paths = initializeList(pathToString,deletePath,comparePaths);
  newGroup->groups = initializeList(groupToString,deleteGroup,compareGroups);
  newGroup->otherAttributes = initializeList(attributeToString,deleteAttribute,compareAttributes);
  return newGroup;
}

/**Recursivly goes into the group and grabs all the groups inside of them
 *@pre list and group must be malloced, valid and not free
 *@param list a group list in which groups will be added to
 *@param group struct*/
void getGroupsFromGroups(List* list, Group* group){
  ListIterator listIterator = createIterator(group->groups);
  void* value;

  //itterates though the main image and grabs all paths in the root of the image

  while((value = nextElement(&listIterator)) != NULL){
    if(value){
      insertBack(list,value);
    }
    getGroupsFromGroups(list,(Group*)value);
  }

}

/**Tests if the svg image is valid.
 *@pre a malloced image
 *@param img malloced SVGimage
 *@return the img will return NULL and freed if no valid.
 */
bool testImg(SVGimage* img){

  if(strcmp(img->namespace,"") == 0){
    //failed test
} else if(!img->rectangles || !img->circles || !img->paths || !img->groups){ //if any of the groups are null
    //failed test
  }else{ //Passed all tests.
    return true;
  }

  //failed tests
  return false;
}

/**test if the given svg doc is valid.*/
bool IsValidSVG(xmlDoc* doc,char* schemaFile){
  xmlSchemaParserCtxt* parserCtxt = NULL;
  xmlSchema* schema = NULL;
  xmlSchemaValidCtxt* ctxt= NULL;
  parserCtxt = xmlSchemaNewParserCtxt(schemaFile);
  schema = xmlSchemaParse(parserCtxt);
  ctxt = xmlSchemaNewValidCtxt(schema);
  bool isValid = false;
  /* if the doc was read correcetly malloc memory for image
   * then parses the XML into the image*/
  isValid = (doc &&  xmlSchemaIsValid(ctxt) == 1 && xmlSchemaValidateDoc(ctxt,doc) == 0 );

  if(parserCtxt) xmlSchemaFreeParserCtxt(parserCtxt);
  if(schema) {
      xmlSchemaFree(schema);

  }
  if(ctxt) xmlSchemaFreeValidCtxt(ctxt);

  return isValid;
}


/**checks if the current SVGimage structure is valid.
 *@param image the image that is being check must not be feed
 *@return returns if the image is valid or not
 */
bool checkSVGimage(SVGimage* image){
    bool isValid = false;
    if(image){
        List* rectList;
        List* circleList;
        List* pathList;
        List* groupList;
        rectList = getRects(image); //gets all elements
        circleList = getCircles(image);
        pathList = getPaths(image);
        groupList = getGroups(image);
        isValid = testImg(image) //checks if they are all valid
                  && isListValid(rectList,checkRects)
                  && isListValid(circleList,checkCircles)
                  && isListValid(pathList,checkPaths)
                  && isListValid(groupList,checkGroups)
                  && isListValid(image->otherAttributes,checkAttribute);
       freeList(rectList); //frees lists used
       freeList(circleList);
       freeList(pathList);
       freeList(groupList);
    }
    return isValid;
}

/***********************UTIL FUNCTION***********************/


/******************XML PARSER FUCNTIONS*******************/
/*************HELPERFUNCTIONS TO PARSE XML FILE****************/
/*Takes in a blank image and files will with the info from doc and root.
@pre the image must already be malloced
@param image the image info will be added to
@param doc the xml doc info is pulled from
@param root the root of the xml tree
*/
void parseText(char* text,xmlNode* textNode){
    xmlNode* currentNode = NULL;
    if(textNode->children != NULL){
        currentNode = textNode->children;
    }
    for (;  currentNode != NULL; currentNode = currentNode->next) {
        if(strcmp((const char*)currentNode->name,"text") == 0){
          strncpy(text,(const char*)currentNode->content,255);
          text[255] = '\0'; //forces a null terminator at the end
          for(int i = 0; i < strlen(text); i++){
            if(text[i] == '\n') text[i] = ' ';
          }
        }
    }
}

/**gets a rect from a rect node
 *@pre must be a rect node ie name == "rectangle"
 *@param rectNode the xml retangle
 *@return the retangle if it could be created if not returns null
 */
void parseRect(List* list,xmlNode* node){
    Rectangle* rect = NULL;

    //used for other attributes
    xmlAttr *xmlAttr = NULL;
    Attribute* attr = NULL;
    Quantity* quantity;
    //int isWidthFound = 0;
    //int isHeightFound = 0;
    rect = malloc(sizeof(Rectangle));
    rect->x = 0;
    rect->y = 0;
    rect->width = 0;
    rect->height = 0;
    rect->units[0] = '\0';

    rect->otherAttributes = initializeList(attributeToString,deleteAttribute,compareAttributes);


    for (xmlAttr = node->properties; xmlAttr != NULL; xmlAttr = xmlAttr->next)
    {
        if(xmlAttr != NULL){
            if(strcmp((char*)xmlAttr->name, "x" ) == 0){ //path data

                //only grabs first one after testing this is what svg seems to do
                quantity = parseNumber((char*)xmlAttr->children->content);
                setAttributeValue(quantity,rect->units,&(rect->x));
                free(quantity);

            } else if(strcmp((char*)xmlAttr->name, "y" ) == 0){ //path data
                quantity = parseNumber((char*)xmlAttr->children->content);
                setAttributeValue(quantity,rect->units,&(rect->y));
                free(quantity);

            } else if(strcmp((char*)xmlAttr->name, "width" ) == 0){ //path data
                //only grabs first one after testing this is what svg seems to do
                quantity = parseNumber((char*)xmlAttr->children->content);
                setAttributeValue(quantity,rect->units,&(rect->width));
                free(quantity);
            } else if(strcmp((char*)xmlAttr->name, "height" ) == 0){ //path data
                //only grabs first one after testing this is what svg seems to do
                quantity = parseNumber((char*)xmlAttr->children->content);
                setAttributeValue(quantity,rect->units,&(rect->height));
                free(quantity);
            } else { //other attributes
                attr = malloc(sizeof(Attribute));
                attr->name = malloc(sizeof(char)*(strlen((char*)xmlAttr->name)+1));
                attr->value = malloc(sizeof(char)*(strlen((char*)xmlAttr->children->content)+1));
                strcpy(attr->name,(char*)xmlAttr->name);
                strcpy(attr->value,(char*)xmlAttr->children->content);
                insertBack(rect->otherAttributes, (void*)attr);
                attr = NULL;
            }
        }

    }

    insertBack(list, (void*)rect);



}

/**parses a path tag from a path node
 *@pre must be a valid node and list
 *@param list list it will be added to must be a path list
 *@param node the node contaning the paths
 */
void parsePath(List* list, xmlNode* node){
    xmlAttr *xmlAttr = NULL;
    Attribute* attr = NULL;

    //init path data
    Path* path = malloc(sizeof(Path));
    path->data = NULL;
    path->otherAttributes = initializeList(attributeToString,deleteAttribute,compareAttributes);

    for (xmlAttr = node->properties; xmlAttr != NULL; xmlAttr = xmlAttr->next)
    {
        if(xmlAttr != NULL){
            if(strcmp((char*)xmlAttr->name, "d" ) == 0 && path->data == NULL){ //path data
                //only grabs first one after testing this is what svg seems to do
                if(strlen((char*)xmlAttr->children->content) > 0){
                    path->data = malloc(sizeof(char)*(strlen((char*)xmlAttr->children->content) +1));
                    strcpy(path->data,(char*)xmlAttr->children->content);
                }

            } else { //other attributes
                attr = malloc(sizeof(Attribute));
                attr->name = malloc(sizeof(char)*(strlen((char*)xmlAttr->name)+1));
                attr->value = malloc(sizeof(char)*(strlen((char*)xmlAttr->children->content)+1));
                strcpy(attr->name,(char*)xmlAttr->name);
                strcpy(attr->value,(char*)xmlAttr->children->content);
                insertBack(path->otherAttributes, (void*)attr);
                attr = NULL;
            }
        }

    }

    //add if was made correcetly
    if(path->data != NULL){
        insertBack(list, (void*)path);
    } else{
        freeList(path->otherAttributes);
        free(path);
    }

}

void getNamespaceFromNode(char* namespace,xmlNode* node){
    if(node->ns != NULL)
        strcpy(namespace,(char*)node->ns->href);
}

void getImageAttributes(List* list,xmlNode* node){
    xmlAttr *xmlAttr = NULL;
    Attribute* attr = NULL;
    for (xmlAttr = node->properties; xmlAttr != NULL; xmlAttr = xmlAttr->next)
    {
        if(xmlAttr != NULL){
            attr = malloc(sizeof(Attribute));
            attr->name = malloc(sizeof(char)*(strlen((char*)xmlAttr->name)+1));
            attr->value = malloc(sizeof(char)*(strlen((char*)xmlAttr->children->content)+1));
            strcpy(attr->name,(char*)xmlAttr->name);
            strcpy(attr->value,(char*)xmlAttr->children->content);
            insertBack(list, (void*)attr);
            attr = NULL;
        } else {

        }

    }
}

/**gets attribute of a type. only will get first one
 *@pre node must not be null
 *@param type the type of attribute trying to be retrived
 *@param node the node you are looking in
 *@return the retrived attribute null if not found
*/
Attribute* getAttributeFromNode(char* type, xmlNode* node){
    // Iterate through every attribute of the current node
    xmlAttr *xmlAttr = NULL;
    Attribute* attr = NULL;
    for (xmlAttr = node->properties; xmlAttr != NULL; xmlAttr = xmlAttr->next)
    {
        if(strcmp((char*)xmlAttr->name,type) == 0){
            attr = malloc(sizeof(Attribute));
            attr->name = malloc(sizeof(char)*(strlen((char*)xmlAttr->name)+1));
            attr->value = malloc(sizeof(char)*(strlen((char*)xmlAttr->children->content)+1));
            strcpy(attr->name,(char*)xmlAttr->name);
            strcpy(attr->value,(char*)xmlAttr->children->content);
            break;
        }

    }
    return attr;
}


/**parses a path tag from a circle node
 *@pre must be a valid node and list
 *@param list list it will be added to must be a circle list
 *@param node the node contaning the cirlce
 */
void parseCircle(List* list,xmlNode* node){
    Circle* circle = NULL;

    //used for other attributes
    xmlAttr *xmlAttr = NULL;
    Attribute* attr = NULL;
    Quantity* quantity;
    //creates circle with default values
    circle = malloc(sizeof(Circle));
    circle->cx = 0;
    circle->cy = 0;
    circle->r = 0;

    circle->units[0] = '\0';

    circle->otherAttributes = initializeList(attributeToString,deleteAttribute,compareAttributes);

    for (xmlAttr = node->properties; xmlAttr != NULL; xmlAttr = xmlAttr->next)
    {
        if(xmlAttr != NULL){
            if(strcmp((char*)xmlAttr->name, "cx" ) == 0){ //path data

                //only grabs first one after testing this is what svg seems to do
                quantity = parseNumber((char*)xmlAttr->children->content);
                setAttributeValue(quantity,circle->units,&(circle->cx));
                free(quantity);

            } else if(strcmp((char*)xmlAttr->name, "cy" ) == 0){ //path data
                quantity = parseNumber((char*)xmlAttr->children->content);
                setAttributeValue(quantity,circle->units,&(circle->cy));
                free(quantity);

            } else if(strcmp((char*)xmlAttr->name, "r" ) == 0){ //path data
                //only grabs first one after testing this is what svg seems to do
                quantity = parseNumber((char*)xmlAttr->children->content);
                setAttributeValue(quantity,circle->units,&(circle->r));
                free(quantity);

            } else { //other attributes
                attr = malloc(sizeof(Attribute));
                attr->name = malloc(sizeof(char)*(strlen((char*)xmlAttr->name)+1));
                attr->value = malloc(sizeof(char)*(strlen((char*)xmlAttr->children->content)+1));
                strcpy(attr->name,(char*)xmlAttr->name);
                strcpy(attr->value,(char*)xmlAttr->children->content);
                insertBack(circle->otherAttributes, (void*)attr);
                attr = NULL;
            }
        }

    }

    insertBack(list, (void*)circle);

}

/**gets group title and desc based on tag
 *@pre valid string and node
 *@param name of tag
 *@param content of tag
 */
void groupTag(xmlNode* node,Group* group){

  if(!node->children){
    return;
  } else if(!node->children->content){
    return;
  }

  Attribute* attr = malloc(sizeof(Attribute));

  attr->name = malloc(sizeof(char)*strlen((char*)node->name)+1);
  attr->value = malloc(sizeof(char)*(strlen((char*)node->children->content)+1));

  strcpy(attr->name,(char*)node->name);
  strcpy(attr->value,(char*)node->children->content);

  insertBack(group->otherAttributes,attr);
}

void parseGroup(Group* group, xmlNode* root){
  Group* newGroup;
  //traverses though the tree depth first
  for (; root != NULL; root = root->next) {

      //if its a valid node type check if its a valid tag for the parser
      if (root->type == XML_ELEMENT_NODE) {
          if (strcmp((const char*)root->name,"rect") == 0) { //gets rect
              parseRect(group->rectangles,root);
          } else if (strcmp((const char*)root->name,"title") == 0) {
              groupTag(root,group);
          } else if (strcmp((const char*)root->name,"desc") == 0) { //gets description
              groupTag(root,group);
          }else if (strcmp((const char*)root->name,"path") == 0) { //gets path
              parsePath(group->paths,root);
          } else if (strcmp((const char*)root->name,"circle") == 0) { //gets circle
              parseCircle(group->circles,root);
          } else if (strcmp((const char*)root->name,"g") == 0) { //gets group
            //malocs for new group;
            newGroup = initGroup();
            getImageAttributes(newGroup->otherAttributes,root); //gets all AtributeInfo on the group node
            parseGroup(newGroup,root->children); //gets all sub elements must start on children or else it will go into endless recursion
            insertBack(group->groups,newGroup);//add to list

            continue; //don't go into the children that will be taken care of by the group.
          } else{
                    //printf("node type: Element, name: %s\n", root->name);
          }
      }

      //goes into the children for depth first search.
      parseGroup(group,root->children);
  }
}
/*************HELPERFUNCTIONS TO PARSE XML FILE****************/

//main function to parse xml in to image
/*Takes in a blank image and files will with the info from doc and root.
@pre the image must already be malloced
@param image the image info will be added to
@param doc the xml doc info is pulled from
@param root the root of the xml tree
*/
void parseXML(SVGimage* image, xmlNode* root){
    Group* group;
    //traverses though the tree depth first
    for (; root != NULL; root = root->next) {

        //if its a valid node type check if its a valid tag for the parser
        if (root->type == XML_ELEMENT_NODE) {
            if (strcmp((const char*)root->name,"svg") == 0) { //gets namespace and other attributes of image
                getNamespaceFromNode(image->namespace,root);
                getImageAttributes(image->otherAttributes,root);
            } else if (strcmp((const char*)root->name,"title") == 0) {
                parseText(image->title,root);
            } else if (strcmp((const char*)root->name,"desc") == 0) { //gets description
                parseText(image->description,root);
            } else if (strcmp((const char*)root->name,"rect") == 0) { //gets rect
                parseRect(image->rectangles,root);
            } else if (strcmp((const char*)root->name,"path") == 0) { //gets path
                parsePath(image->paths,root);
            } else if (strcmp((const char*)root->name,"circle") == 0) { //gets circle
                parseCircle(image->circles,root);
            } else if (strcmp((const char*)root->name,"g") == 0) { //gets group
                //malocs for new group;
                group = initGroup();
                getImageAttributes(group->otherAttributes,root); //get other attributes
                parseGroup(group,root->children); //parses the sub elements
                insertBack(image->groups,group); //add to list
                continue; //don't go into the children that will be taken care of by the group.
            } else{
                      //printf("node type: Element, name: %s\n", root->name);
            }
        }

        //goes into the children for depth first search.
        parseXML(image,root->children);
    }
}




/******************XML PARSER FUCNTIONS*******************/


/********************SVGTOXML FUNCTIONS********************/

/**Takes in a svg image and converts it to a xmlTree
    @pre img is malloced and not null
    @param img the image should be valid and not freed
    @return a tree reperenstation of the image
    */
xmlDoc* SVGimageToTree(SVGimage* image){

    //failed image is null
    if(!image) return NULL;

    //creates the svg doc and sets the root node*/
    xmlDoc* doc = xmlNewDoc(BAD_CAST "1.0");
    xmlNode* root = xmlNewNode(NULL, BAD_CAST "svg");
    xmlDocSetRootElement(doc, root);
    /**Sets the nameSpace to the rootNode*/
    setSVGTreeNS(root,image);

    /**sets properties to the svg root node*/
    setSVGTreeAttributes(root,image->otherAttributes);

    /**if the title and description exist add them*/
    if(*(image->title) != '\0'){
        textToXmlNode(root, "title", image->title);
    }
    if(*(image->description) != '\0'){
        textToXmlNode(root, "desc", image->description);
    }

    /**adds the list of elements*/
    addListToNode(root,image->rectangles,rectToNode);
    addListToNode(root,image->circles,circleToNode);
    addListToNode(root,image->paths,pathsToNode);
    addListToNode(root,image->groups,groupsToNode);



    return doc;
}

/**sets the other attributes to a given node
 *@pre nothing is null or freed
 *@node the node the other attirbutes are being added too.
  *@attributes the otherattributes list that are getting added to the node.
*/
void setSVGTreeAttributes(xmlNode* node,List* list){

    ListIterator listIterator;
    Attribute* attr;
    void* value;
    if(node && list){
      listIterator = createIterator(list);
      //goes through all attributes adding them to the node
      while((value = nextElement(&listIterator)) != NULL){
        attr = (Attribute*)value;

        //checks if its a valid attribute
        if(checkAttribute(attr) == false) continue;
        /*if its title or description it goes in its own subnode, only will happen for groups*/
        if(strcmp(attr->name,"title") == 0 || strcmp(attr->name,"desc") == 0){
            textToXmlNode(node, attr->name,attr->value);
        } else{ //else it is a normal attribute and just is added to the node
            xmlNewProp(node,BAD_CAST attr->name,BAD_CAST attr->value);
        }

      }
    }


}

/**takes in the root node and sets the nameSpace.
 *@pre nothing is null or freed
 *@root the node ns will be added to
 *@img the image that the namespace is in*/
void setSVGTreeNS(xmlNode* root, SVGimage* img){
    if(root && img){
        xmlNs* ns = xmlNewNs(root,BAD_CAST img->namespace,NULL);
        xmlSetNs(root,ns);
    }
}

/**creates a tag of name name and sets the text content to node
 *@pre nothing is freed or null
 *@param node the node that will be the parent to the text
 *@param name the name of the text node
 *@param text the text to be added the the node*/
void textToXmlNode(xmlNode* node, const char* name, const char* text){
    if(node && name && text)
        xmlNewTextChild(node,NULL, BAD_CAST name,BAD_CAST text);
}

/**adds the list to a node based on a function pointer
 *@pre nothing is null or freed a valid adder function
 *@param node the parent the node info is being added to
 *@param list the list that is being added to the node children
 *@param adder the function that will add the list to the node
*/
void addListToNode(xmlNode* node, List* list, void (*adder)(xmlNode* node,void* element)){
    ListIterator listIterator;
    void* value;
    if(node && list){
      listIterator = createIterator(list);
      //goes through all attributes adding them to the node
      while((value = nextElement(&listIterator)) != NULL){
        adder(node,value); //the helper function will add it to the subnode
      }
    }
}


/**Helper function  to convert elements to nodes*/

void rectToNode(xmlNode* node,void* element){
    Rectangle * rect = (Rectangle*)element;
    char buffer[1000];
    *buffer = '\0';
    if(rect && element){
        xmlNode* rectNode = xmlNewChild(node,NULL,BAD_CAST  "rect",NULL);
        sprintf(buffer,"%f%s",rect->x,rect->units);
        xmlNewProp(rectNode,BAD_CAST "x",BAD_CAST buffer);
        sprintf(buffer,"%f%s",rect->y,rect->units);
        xmlNewProp(rectNode,BAD_CAST "y",BAD_CAST buffer);
        sprintf(buffer,"%f%s",rect->width,rect->units);
        xmlNewProp(rectNode,BAD_CAST "width",BAD_CAST buffer);
        sprintf(buffer,"%f%s",rect->height,rect->units);
        xmlNewProp(rectNode,BAD_CAST "height",BAD_CAST buffer);
        setSVGTreeAttributes(rectNode,rect->otherAttributes);
    }
}
void circleToNode(xmlNode* node,void* element){
    Circle * circle = (Circle*)element;
    char buffer[1000];
    *buffer = '\0';
    if(circle && element){
        xmlNode* circleNode = xmlNewChild(node,NULL,BAD_CAST  "circle",NULL);
        sprintf(buffer,"%f%s",circle->cx,circle->units);
        xmlNewProp(circleNode,BAD_CAST "cx",BAD_CAST buffer);
        sprintf(buffer,"%f%s",circle->cy,circle->units);
        xmlNewProp(circleNode,BAD_CAST "cy",BAD_CAST buffer);
        sprintf(buffer,"%f%s",circle->r,circle->units);
        xmlNewProp(circleNode,BAD_CAST "r",BAD_CAST buffer);
        setSVGTreeAttributes(circleNode,circle->otherAttributes);
    }
}
void pathsToNode(xmlNode* node,void* element){
    Path * path = (Path*)element;

    if(path && element && path->data){
        xmlNode* pathNode = xmlNewChild(node,NULL,BAD_CAST  "path",NULL);
        xmlNewProp(pathNode,BAD_CAST "d",BAD_CAST path->data);
        setSVGTreeAttributes(pathNode,path->otherAttributes);
    }

}
void groupsToNode(xmlNode* node,void* element){
    Group* group = (Group*)element;
    if(node && element){
        xmlNode* groupNode = xmlNewChild(node,NULL,BAD_CAST  "g",NULL);
        /**adds the list of elements*/
        addListToNode(groupNode,group->rectangles,rectToNode);
        addListToNode(groupNode,group->circles,circleToNode);
        addListToNode(groupNode,group->paths,pathsToNode);
        addListToNode(groupNode,group->groups,groupsToNode);
        setSVGTreeAttributes(groupNode,group->otherAttributes);

    }

}
/********************SVGTOXML FUNCTIONS********************/

/********************SVG editorfubnctions ******************/
//helper functions for adding components to the svgImage
/**
 *@pre must take in a valid svgImage and a valid attribute
 *@param SVGimage a malloced an not freed SVGimage.
              the image the new obj will be added too
  *@param obj the object to be added. if wrong object is entered it will fail and crash
  */
void addCircle(SVGimage*image ,void* obj){
    if(image && obj && image->circles && ((Circle*)obj)->otherAttributes){
        insertBack(image->circles,obj);
    }
}
void addRect(SVGimage* image,void* obj){
    if(image && obj && image->rectangles&& ((Rectangle*)obj)->otherAttributes){
        insertBack(image->rectangles,obj);
    }
}
void addPath(SVGimage* image,void* obj){
    if(image && obj && image->circles && checkPaths(obj)){
        insertBack(image->paths,obj);
    }
}

void addAttrSVGimage(SVGimage* image, int elementIndex,Attribute* attr){
  if(checkAttribute(attr) && image){ //index must be zero for image
    if(strcmp(attr->name,"title") == 0){
      strncpy(image->title,attr->value,255);
      (image->title)[255] = '\0';
    } else if (strcmp(attr->name,"desc") == 0){
      strncpy(image->title,attr->value,255);
      (image->description)[255] = '\0';
    } else if (strcmp(attr->name,"namespace") == 0){
      strncpy(image->title,attr->value,255);
      (image->namespace)[255] = '\0';
    } else {
      addOtherAttr(image->otherAttributes,attr);
    }
  } else{
    deleteAttribute(attr);
  }
}
void addAttrRect(SVGimage* image, int elementIndex,Attribute* attr){
  Rectangle* rect;
  if(checkAttribute(attr) && image){ //index must be zero for image
    rect = getComponentFromList(image->rectangles,elementIndex);
    if(!rect) return; //error invalid index or doesnt exists

    //holds the new quantity
    Quantity* quantity = NULL;

    if(strcmp(attr->name,"x") == 0){ //changes x's value
      quantity = parseNumber(attr->value);
      if(quantity) rect->x = quantity->value;
      deleteAttribute(attr);
  } else if (strcmp(attr->name,"y") == 0){ //changes y's value
      quantity = parseNumber(attr->value);
      if(quantity) rect->y = quantity->value;
      deleteAttribute(attr);

  } else if (strcmp(attr->name,"width") == 0){ //changes width value
      quantity = parseNumber(attr->value);
      if(quantity) rect->width = quantity->value;
      deleteAttribute(attr);

  } else if (strcmp(attr->name,"height") == 0){ //changes height

      quantity = parseNumber(attr->value);
      if(quantity) rect->height  = quantity->value;
      deleteAttribute(attr);
  }else if (strcmp(attr->name,"units") == 0){ //changes units

      strncpy(rect->units,attr->value,50);
      (rect->units)[49] = '\0';
      deleteAttribute(attr);
    }else {
      addOtherAttr(rect->otherAttributes,attr);
    }

    if(quantity) free(quantity);
  } else{
    deleteAttribute(attr);
  }
}
void addAttrCircle(SVGimage* image, int elementIndex,Attribute* attr){
  Circle* circle;
  if(checkAttribute(attr) && image){ //index must be zero for image
    circle = getComponentFromList(image->circles,elementIndex);
    if(!circle) return; //error invalid index or doesnt exists

    Quantity* quantity = NULL;

    if(strcmp(attr->name,"cx") == 0){
      quantity = parseNumber(attr->value);
      if(quantity) circle->cx = quantity->value;
      deleteAttribute(attr);
    } else if (strcmp(attr->name,"cy") == 0){
      quantity = parseNumber(attr->value);
      if(quantity) circle->cy = quantity->value;
      deleteAttribute(attr);
    } else if (strcmp(attr->name,"r") == 0){
      quantity = parseNumber(attr->value);
      if(quantity) circle->r = quantity->value;
      deleteAttribute(attr);
    } else if (strcmp(attr->name,"units") == 0){

      strncpy(circle->units,attr->value,50);
      (circle->units)[49] = '\0';
      deleteAttribute(attr);
    }else {
      addOtherAttr(circle->otherAttributes,attr);
    }

    if(quantity) free(quantity);
  } else{
    deleteAttribute(attr);
  }
}
void addAttrPath(SVGimage* image, int elementIndex,Attribute* attr){
  Path* path;
  if(checkAttribute(attr) && image){ //index must be zero for image
    path = getComponentFromList(image->paths,elementIndex);
    if(!path) return; //error invalid index or doesnt exists


    if(strcmp(attr->name,"d") == 0){
      free(path->data);
      path->data = malloc(sizeof(char)*(strlen(attr->value) + 1));
      strcpy(path->data,attr->value);
      deleteAttribute(attr);
    } else {
      addOtherAttr(path->otherAttributes,attr);
    }

  } else{
    deleteAttribute(attr);
  }
}
void addAttrGroup(SVGimage* image, int elementIndex,Attribute* attr){
  Group* group;
  if(checkAttribute(attr) && image){ //index must be zero for image
    group = getComponentFromList(image->groups,elementIndex);
    if(!group) return; //error invalid index or doesnt exists

    addOtherAttr(group->otherAttributes,attr);

  } else{
    deleteAttribute((void*)attr);
  }
}

/**checks if an element exists in the other lists or else it will add it
 *@param list the otherAttribute list being added to
 *@param attr the attribute that is being added
 */
void addOtherAttr(List* list,Attribute* attr){
  void* value = NULL;
  Attribute* otherAttr;
  if(list){
    ListIterator listIterator = createIterator(list);
    while((value = nextElement(&listIterator)) != NULL){
      otherAttr = (Attribute*)value;
      if(strcmp(attr->name,otherAttr->name) == 0 ){ //attribute found
        free(otherAttr->value);
        otherAttr->value = malloc(sizeof(char)*(strlen(attr->value) + 1));
        strcpy(otherAttr->value,attr->value);
        deleteAttribute(attr);
        return;
      }
    }
    //attribute not found
    insertBack(list,attr);
  }
}
/*gets a value at given index. used for adding attributes to a component
 *@param a given list to be iterated thru
 *@param indexc the index that the element is being grabbed from
 *@return the element gotten form the index in the list returns NULL if its out of index
 */
void* getComponentFromList(List* list, int index){
  void* value = NULL;
  if(list){
    ListIterator listIterator = createIterator(list);
    //work done in loop
    for(int i = 0; i <= index && (value = nextElement(&listIterator)); i++);
  }
  return value;
}



/********************SVG editorfubnctions ******************/

/************************Functions for JS********************/
/**gets an json of a valid svg image strings
 *@param fileName the name of the file will be assumed to be inside
     the uploads folder
 *@return json of all valid svg images*/
char* getValidSVGimage(char* fileName){
  SVGimage* img = createValidSVGimage(fileName,SCHEMA);
  char* imgString = NULL;
  if(img){
    imgString = SVGtoJSON(img);
  }
  deleteSVGimage(img);
  return imgString;
}

/**sets an attribute to an object
 *@param fileName the name that is going to be changed
 *@param elemType the type of element to value of ENUM
 *@param elemIndex the index of the element type
 *@param attrName the attributes name
 *@param attrValue value of the attribute
 *@return returns an error code 1 means success*/
int setAttributeToFile(char* fileName,int elemType, int elemIndex,char* attrName, char* attrValue){

  int flag = 1;
  SVGimage* img = createValidSVGimage(fileName,SCHEMA);
  if(img){
    Attribute* attr = malloc(sizeof(Attribute));
    attr->name = malloc(sizeof(char)*strlen(attrName)+1);
    attr->value = malloc(sizeof(char)*strlen(attrValue)+1);
    strcpy(attr->name,attrName);
    strcpy(attr->value,attrValue);
    setAttribute(img,elemType,elemIndex,attr);
    if(!validateSVGimage(img,SCHEMA)){
      flag = 0;
    }else {
      writeSVGimage(img,fileName);
    }
    //fail
  } else{
    flag = 0;
  }

  deleteSVGimage(img);
  return flag;
}

/**adds either a circle or rectangle to an fileName
 *@param fileName the fileName of the component
 *@param rectOrCircle if its 0 its a circle 1 its a rect
 *@param compoent the component shape
 *@return int the error code
*/
int addComponentToFile(char* fileName, int rectOrCircle, char* component){
  int flag = 1;
  SVGimage* img = createValidSVGimage(fileName,SCHEMA);
  if(img){
    void* comp = NULL;
    elementType type = RECT;
    if(rectOrCircle){//rectangle
      comp = JSONtoRect(component);
    } else{ //circle
      comp = JSONtoCircle(component);
      type = CIRC;
    }
    addComponent(img,type,comp);
    if(!comp || !validateSVGimage(img,SCHEMA)){
      flag = 0;
    }else {
      writeSVGimage(img,fileName);
    }
    //fail
  } else{
    flag = 0;
  }

  deleteSVGimage(img);
  return flag;
}

/**Creates an svg from a json struct
 *@param fileName the file that it will be saved to
 *@param SVGstring the string to be converted into an svg
 *@return int the error code*/
int saveSVGtoFile(char* fileName, char* SVGstring){

  SVGimage* img = JSONtoSVG(SVGstring);
  if(img && validateSVGimage(img, SCHEMA)){

    writeSVGimage(img,fileName);
    return 1;
  }
  return 0;
}

/**returns a string as Json that holds the info on a given svg
 *@param fileName the name of the file to get components from
 *@return returens a Json string holding an array of components*/
char* getComponents(char* fileName){
    char* compString = NULL;
    SVGimage* img = createValidSVGimage(fileName,SCHEMA);
    if(img){

      char* rectString = rectListToJSON(img->rectangles);
      char* circleString = circListToJSON(img->circles);
      char* pathString = pathListToJSON(img->paths);
      char* groupString = groupListToJSON(img->groups);
      compString = malloc(
        sizeof(char)*(
          strlen(rectString)+
          strlen(circleString)+
          strlen(pathString)+
          strlen(groupString)+1+
          strlen(img->title) +
          strlen(img->description) +
          strlen("{\"title\":\"\",\"desc\":\"\",\"rects\":,\"paths\":,\"circles\":,\"groups\":}")));
      sprintf(compString,"{\"title\":\"%s\",\"desc\":\"%s\",\"rects\":%s,\"paths\":%s,\"circles\":%s,\"groups\":%s}",
          img->title,img->description,rectString,pathString,circleString,groupString);

      free(rectString);
      free(circleString);
      free(pathString);
      free(groupString);
      deleteSVGimage(img);

    }
    return compString;
}


/**gets the attributes from an object
 *@param fileName the file attributes are being retrived from
 *@param elemType the type of the element based on ElementType enum
 *@param elemIndex the index of the element for SVGimage index doesn't matter
 *@return a JSON {attr:[],otherAttr[]} attr is needed attributes for the objects
     otherAtter is atributes that were added on but not needed*/
char* getAttributesFromFile(char* fileName,int elemType, int elemIndex){
  /**This array holds the functions pointers used to set attributes in the lists.
     * it is based on the same index as elemType
     *typedef enum COMP{ SVG_IMAGE, CIRC, RECT, PATH, GROUP } elementType;
     */
    char* (*getAttributeFunctions[5])(SVGimage*, int) = {getAttrSVGimage, getAttrCircle,getAttrRect,getAttrPath,getAttrGroup};

    SVGimage* image = createValidSVGimage(fileName,SCHEMA);

    if(!image){
        return NULL;
    }
    //checks bounds and adds the attribute if it exists
    if(elemType >= SVG_IMAGE && elemType <= GROUP){
        char* str = getAttributeFunctions[elemType](image,elemIndex);
        deleteSVGimage(image);
        return str;
    }
    return NULL;
}

/*helper functions to get the attributes of an object.
 *returns a JSON in this format
    JSON {attr:{"needed attrs"},otherAttr:["extra atter"]}
*/
char* getAttrSVGimage(SVGimage* img, int index){
  char* otherAttr = attrListToJSON(img->otherAttributes);
  char* JSON = malloc(sizeof(char)*
                     (strlen(img->description)+
                      strlen(img->title) +
                      strlen(otherAttr)+
                      strlen("{\"attr\":{\"title\":\"\",\"descr\":\"\"},\"otherAttr\":}")+1));
  sprintf(JSON,"{\"attr\":{\"title\":\"%s\",\"descr\":\"%s\"},\"otherAttr\":%s}",img->title,img->description,otherAttr);
  free(otherAttr);
  return JSON;
}
char* getAttrCircle(SVGimage* img, int index){
  Circle* circle = getComponentFromList(img->circles,index);
  char* circleJSON = circleToJSON(circle);
  char* otherAttr = attrListToJSON(circle->otherAttributes);
  char* JSON = malloc(sizeof(char)*
                     (strlen(circleJSON)+
                      strlen(otherAttr)+
                      strlen("{\"attr\":,\"otherAttr\":}")+100));
  sprintf(JSON,"{\"attr\":%s,\"otherAttr\":%s}",circleJSON,otherAttr);
  free(circleJSON);
  free(otherAttr);
  return JSON;
}
char* getAttrRect(SVGimage* img, int index){
  Rectangle* rect = getComponentFromList(img->rectangles,index);

  char* rectJSON = rectToJSON(rect);
  char* otherAttr = attrListToJSON(rect->otherAttributes);
  char* JSON = malloc(sizeof(char)*
                     (strlen(rectJSON)+
                      strlen(otherAttr)+
                      strlen("{\"attr\":,\"otherAttr\":}")+100));
  sprintf(JSON,"{\"attr\":%s,\"otherAttr\":%s}",rectJSON,otherAttr);
  free(rectJSON);
  free(otherAttr);
  return JSON;
}
char* getAttrPath(SVGimage* img, int index){
  Path* path = getComponentFromList(img->paths,index);
  char* pathJSON = pathToJSON(path);
  char* otherAttr = attrListToJSON(path->otherAttributes);
  char* JSON = malloc(sizeof(char)*
                     (strlen(pathJSON)+
                      strlen(otherAttr)+
                      strlen("{\"attr\":,\"otherAttr\":}")+1));
  sprintf(JSON,"{\"attr\":%s,\"otherAttr\":%s}",pathJSON,otherAttr);

  free(pathJSON);
  free(otherAttr);
  return JSON;
}
char* getAttrGroup(SVGimage* img, int index){
  Group* group = getComponentFromList(img->groups,index);
  char* otherAttr = attrListToJSON(group->otherAttributes);
  char* JSON = malloc(sizeof(char)*
                     (strlen(otherAttr)+
                      strlen("{\"attr\":,\"otherAttr\":}")+1));
  sprintf(JSON,"{\"otherAttr\":%s}",otherAttr);

  free(otherAttr);
  return JSON;
}

//write scalling functions should be easy
//idea getRects && getCircles loop scaling by factor write to disk
//elemType for what to scale 0 for circles 1 for rects 2 for both
/**scales the shapes of a given type 0 := circle 1 := rect 2:=both
 *@param fileName the file of the svg that will be edited
 *@param elemType 0 for circles 1 for rects 2 for both
 *@param scaleFactor the factor shapes will be mutiplied for
 *@return ErrorCode the error code of the function 1 bad 0 good*/
int scaleShapes(char* fileName,int elmType,float scaleFactor){
    SVGimage* img = createValidSVGimage(fileName,SCHEMA);
    if(img){ //image exists so its valid
        ListIterator listIterator;
        void* value;
        if(elmType == 0){ //circle
            List* circleList = getCircles(img);
            listIterator = createIterator(circleList);
            while((value = nextElement(&listIterator)) != NULL){
              if(value){
                Circle* circle = (Circle*) value;
                circle->r *= scaleFactor;
              }
            }
            freeList(circleList);

        } else if(elmType == 1){ //rect
            List* rectList = getRects(img);

            listIterator = createIterator(rectList);
            while((value = nextElement(&listIterator)) != NULL){
              if(value){
                Rectangle* rect = (Rectangle*) value;

                rect->width *= scaleFactor;
                rect->height *= scaleFactor;
              }
            }
            freeList(rectList);

        }else{ //img
            /*
            List* circleList = getCircles(img);
            List* rectList = getRects(img);
            //RECTS
            listIterator = createIterator(rectList);
            while((value = nextElement(&listIterator)) != NULL){
              if(value){
                Rectangle* rect = (Rectangle*) value;
                if(strcmp("%",rect->units) != 0){
                  rect->x *= scaleFactor;
                  rect->y *= scaleFactor;
                }
                rect->width *= scaleFactor;
                rect->height *= scaleFactor;
              }
            }
            //CIRCLES
            listIterator = createIterator(circleList);
            while((value = nextElement(&listIterator)) != NULL){
              if(value){
                Circle* circle = (Circle*) value;
                if(strcmp("%",circle->units) != 0){
                  circle->cx *= scaleFactor;
                  circle->cy *= scaleFactor;
                }
                circle->r *= scaleFactor;
              }
            }*/
            //find view box
            int isChangedWidth = 0;
            int isChangedHeight = 0;
            char buffer[1000];
            listIterator = createIterator(img->otherAttributes);
            while((value = nextElement(&listIterator)) != NULL){
              if(value){
                Attribute* attr = (Attribute*) value;
                if(strcmp("width",attr->name) == 0){
                  isChangedWidth = 1;
                  Quantity* num =  parseNumber(attr->value);
                  num->value *= scaleFactor; //double width
                  snprintf(buffer,1000,"%.2f%s",num->value,num->unit);
                  buffer[999] = '\0';
                  free(attr->value);
                  free(num);
                  attr->value = malloc(strlen(buffer)+1);
                  strcpy(attr->value,buffer);
                } else if(strcmp("height",attr->name) == 0){
                  isChangedHeight = 1;
                  Quantity* num =  parseNumber(attr->value);
                  num->value *= scaleFactor; //double width
                  snprintf(buffer,1000,"%.2f%s",num->value,num->unit);
                  buffer[999] = '\0';
                  free(attr->value);
                  free(num);
                  attr->value = malloc(strlen(buffer)+1);
                  strcpy(attr->value,buffer);
                }
              }
            }
            if(!isChangedWidth){
              char buffer[1000];
              Attribute* attr = malloc(sizeof(Attribute));
              attr->name = malloc(strlen("width")+1);
              strcpy(attr->name,"width");
              float scale = 100*scaleFactor;
              snprintf(buffer,1000,"%.2f%%",scale);
              buffer[999] = '\0';
              attr->value = malloc(strlen(buffer));
              strcpy(attr->value,buffer);
              setAttribute(img,SVG_IMAGE,0,attr);

            }
            if(!isChangedHeight){
              char buffer[1000];
              Attribute* attr = malloc(sizeof(Attribute));
              attr->name = malloc(strlen("height")+1);
              strcpy(attr->name,"height");
              float scale = 100*scaleFactor;
              snprintf(buffer,1000,"%.2f%%",scale);
              buffer[999] = '\0';
              attr->value = malloc(strlen(buffer));
              strcpy(attr->value,buffer);
              setAttribute(img,SVG_IMAGE,0,attr);
            }
            //free memory from lists
            //freeList(circleList);
            //freeList(rectList);


        }
        if(validateSVGimage(img,SCHEMA)){ //no problems write to file
            writeSVGimage(img,fileName);
            return 0;
        } else return 1;
    } else{
        return 1;
    }
}
